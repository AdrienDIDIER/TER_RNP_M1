<!doctype html>

<html>
<head>
  <meta charset="utf-8">

  <title>Interface web</title>

  <link rel="stylesheet" type="text/css" href="/css/styles.css" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
  <link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/1.10.20/css/jquery.dataTables.css">
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/simplebar@latest/dist/simplebar.css"
    />
    <script src="https://cdn.jsdelivr.net/npm/simplebar@latest/dist/simplebar.min.js"></script>
</head>

<body>
    <style>
        .link {
          fill: none;
          stroke: #000;
          stroke-opacity: .2;
        }
        .link:hover {
          stroke-opacity: .5;
        }
        #params{
            margin: 15px;
        }
        </style>                                                                                                                                                        
    
    <canvas id="canvas" 
        style="z-index: 1;
        position:absolute;
        left:420px;
        top:0px;
        " width="1920" height="1080">
    </canvas>
    <div id="my_dataviz"
    style="z-index: 3;
    position:absolute;
    left:420px;
    top:0px;
    " width="1920" height="1080">

    </div>  
    <div id="side_panel" style="top: 0px;
                width: 420px;
                left: 0px;">
        <div id="params">
            <div class="dropdown">
                Charger fichier : 
                <button id="btn-charger-fichier" class="btn btn-secondary dropdown-toggle" type="button" id="dropdownMenuButton" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                {{current_dir_name}}
                </button>
                <div id="charger-fichier" class="dropdown-menu" aria-labelledby="dropdownMenuButton">
                    {{#dirs}}
                    <a class="dropdown-item" href="/data/{{.}}">{{.}}</a>
                    {{/dirs}}
                </div>
            </div>
            <br>
            <div class="dropdown">
                Affichage :
                <button id="btn-affichage" class="btn btn-secondary dropdown-toggle" type="button" id="dropdownMenuButton" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                Vue d'ensemble
                </button>
                <div id="affichage" class="dropdown-menu" aria-labelledby="dropdownMenuButton">
                    <a class="dropdown-item" href="#">Vue d'ensemble</a>
                    <a class="dropdown-item" href="#">Group By Input Class + Signature</a>
                    <a class="dropdown-item" href="#">Group By Output Class</a>
                    <a class="dropdown-item" href="#">Group By Signature</a>
                </div>
            </div>
        </div>
        <table id="dtVerticalScrollExample" class="table table-dark table-striped table-bordered table-sm" cellspacing="0"
        width="100%" height="100%">
            <thead>
                <tr>
                    <th class="th-sm" scope="col">Input</th>
                    <th class="th-sm" scope="col">Signature</th>
                    <th class="th-sm" scope="col">Output</th>
                    <th class="th-sm" scope="col">Occurence</th>
                </tr>
            </thead>
            <tbody>
                {{#tab_values}}
                <tr id="dark_row" data-index_number="{{index}}">
                    <td>{{input_class}}</td>
                    <td>{{signature_text}}</td>
                    <td>{{output_class}}</td>
                    <td>{{instances}}</td>
                </tr>
                {{/tab_values}}
            </tbody>
        </table>
    </div>

    <button style="z-index: 4;
    position:absolute;
    left: 440px;
    bottom: 10px;" type="button" class="btn btn-secondary" data-container="body" data-toggle="popover" data-placement="top" data-html="true" data-content="{{modele_text}}">Informations sur le mod√®le</button>
  <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
  <script type="text/javascript" charset="utf8" src="https://cdn.datatables.net/1.10.20/js/jquery.dataTables.js"></script>

  <script src="https://d3js.org/d3.v4.min.js"></script>

  <!-- Load the sankey.js function -->
  <script src="https://cdn.jsdelivr.net/gh/holtzy/D3-graph-gallery@master/LIB/sankey.js"></script>

  <script>

$(function () {
  $('[data-toggle="popover"]').popover()
})

        $(function(){

            $("#charger-fichier").on('click', 'a', function(){
                $("#btn-charger-fichier").text($(this).text());
                $("#btn-charger-fichier").val($(this).text());
            });

        });

        $(function(){

            $("#affichage").on('click', 'a', function(){
                $("#btn-affichage").text($(this).text());
                $("#btn-affichage").val($(this).text());
                if($('#btn-affichage').text() === "Vue d'ensemble"){
                    AFFICHAGE_COURANT = loadSankeyVueDensemble
                    $('tbody tr').removeAttr('id').siblings().attr('id', 'dark_row')
                    AFFICHAGE_COURANT(rect_arcs_neurones, coordClusters, clustersColors)
                }else if($('#btn-affichage').text() === "Group By Input Class + Signature"){
                    $('tbody tr:first').addClass('bg-primary').siblings().removeClass('bg-primary');
                    $('tbody tr:first').removeAttr('id').siblings().attr('id', 'dark_row')
                    AFFICHAGE_COURANT = loadSankey
                    drawSignature($('tbody tr:first').data('index_number'))
                }
            });

        });

        $("g").on('mouseover', '.link', function(){
            
        }).mouseleave(function(){
            var link_color = $(this).attr('color')
            $('.link[color="'+link_color+'"').css('stroke-opacity', '0.2')
        });



        //fairte vue d'ensemble et group by

        var window_height = $(window).height();
        var window_width = $(window).width();
        var INTERFACE_HEIGHT = window_height - 100
        var VIS_HEIGHT = INTERFACE_HEIGHT - 50
        var TEXT_HEIGHT = INTERFACE_HEIGHT - VIS_HEIGHT

        var TABLE_WIDTH = 420
        var INTERFACE_WIDTH =  window_width - TABLE_WIDTH

        window_height = $(window).height();

        var AFFICHAGE_COURANT = loadSankeyVueDensemble

        function resizeCanvas(window_height){           
            INTERFACE_HEIGHT = window_height - 100
            VIS_HEIGHT = INTERFACE_HEIGHT - 50
            canvas.height = window_height - 30
            MAX_NODES_PER_COLONNE = VIS_HEIGHT / (MIN_NEURONE_SIZE * 2 + ESPACE_MIN_ENTRE_NEURONE)      
            rect_arcs_neurones = draw();
            canvas.width = rect_arcs_neurones[rect_arcs_neurones.length - 1].x + 150
            rect_arcs_neurones = draw();
            //polygons_paths = drawClusters(rect_arcs_neurones, coordClusters)
            AFFICHAGE_COURANT(rect_arcs_neurones, coordClusters, clustersColors)

        }

        $( window ).resize(function() {
            window_height = $(window).height();
            $('#side_panel').height(window_height)
            resizeCanvas(window_height)
        });

        // $('#canvas').height(INTERFACE_HEIGHT)
        // $('#clusters_canvas').height(INTERFACE_HEIGHT)

        $(document).ready(function () {

            $('#dtVerticalScrollExample').DataTable({
                "scrollY": "100vh",
                "scrollCollapse": true,
                "paging":         false,
                "searching": false,
                "stripeClasses": [ 'strip1', 'strip2', 'strip3' ],
                "bInfo" : false
            });
            $('.dataTables_length').addClass('bs-select');

            $('.dataTables_scrollBody').each(function(){
                new SimpleBar($(this)[0], { autoHide: false });
                $(this).css('overflow', '')
            });

        });

        $('table').on('click', 'tbody tr', function(event) {
            $(this).addClass('bg-primary').siblings().removeClass('bg-primary');
            $(this).removeAttr('id').siblings().attr('id', 'dark_row')
            AFFICHAGE_COURANT = loadSankey
            $("#btn-affichage").text("Group By Input Class + Signature + Output Class");
            $("#btn-affichage").val("Group By Input Class + Signature + Output Class");
            drawSignature($(this).data('index_number'))
        });

        //SANKEY GRAPH
        // set the dimensions and margins of the graph

        function pgcd(x, y) {
            if ((typeof x !== 'number') || (typeof y !== 'number')) 
                return false;
            x = Math.abs(x);
            y = Math.abs(y);
            while(y) {
                var t = y;
                y = x % y;
                x = t;
            }
            return x;
        }

        function getHauteurLargeurLayer(nodes_number){
            if(nodes_number > MAX_NODES_PER_COLONNE ){
                var max = 0
                var i_save = 0
                var j_save = 0
                for(var i = 1; i <= MAX_NODES_PER_COLONNE; i++){
                    for(var j = nodes_number - 10; j <= nodes_number; j++){
                        var z = pgcd(i,j)
                        if(z < MAX_NODES_PER_COLONNE & z > max){
                            max = z
                            i_save = i
                            j_save = j
                        }
                    }
                }
                return [i_save, j_save/i_save, nodes_number - j_save]
            }
            return [1, nodes_number, 0]
        }

        function getNbClusters(all_clusters){
            max = 0
            for(var elem in all_clusters[0]){
                if(max < parseInt(all_clusters[0][elem].cluster_index)){
                    max = parseInt(all_clusters[0][elem].cluster_index)
                }
            }
            return max + 1
        }

        function getInputClasses(clusterized_values){
            input_classes = []
            for(var v of clusterized_values){
                if(!input_classes.includes(parseInt(v["input_class"]))){
                    input_classes.push(parseInt(v["input_class"]))
                }
            }
            return input_classes
        }

        function getOutputClasses(clusterized_values, all_clusters){
            output_classes = []
            for(var v of clusterized_values){
                if(!output_classes.includes(parseInt(v["output_class"]))){
                    output_classes.push(parseInt(v["output_class"]))
                }
                for(var a of all_clusters){
                    for(var c of a){
                        if(!output_classes.includes(parseInt(c["class"]))){
                            output_classes.push(parseInt(c["class"]))
                        }
                    }                   
                }
            }
            return output_classes
        }

        var canvas;
        var context;

        var all_clusters = {{{ all_clusters }}}
        
        var info_network = {{{ info_network }}}

        var nb_layers = all_clusters.length
        var nb_clusters = getNbClusters(all_clusters)
        var nb_classes = info_network[info_network.length - 1].units

        var clusterized_values = {{{ clusterized_values }}}

        var input_classes = getInputClasses(clusterized_values)
        var output_classes = getOutputClasses(clusterized_values, all_clusters)

        var rect_arcs_neurones;
        var coordClusters;

        var clustersColors;

        window.addEventListener('load', function () {
            canvas = document.querySelector('#canvas');
            context = canvas.getContext('2d');

            canvas.style.display="none";

            canvas.height = window_height - 30

            //draw neural network
            rect_arcs_neurones = draw();

            canvas.width = rect_arcs_neurones[rect_arcs_neurones.length - 1].x + 150

            rect_arcs_neurones = draw();
            
            //draw clusters
            coordClusters = new Array(nb_layers)
            coordClusters[0] = new Array()
            for(var i = 0; i < input_classes.length; i++){
                coordClusters[0].push(new Object({'clust_index': input_classes[i], 'proportion': (1/input_classes.length)}))
            }
            for(var i = 0;i < nb_layers;i++){
                coordClusters[i+1] = calculClusters(all_clusters[i], nb_clusters, clusterized_values, (i+1))
            }
            //coordClusters.concat(calculClustersSignatures(clusterized_values, nb_clusters, nb_layers))
            output_nodes = getOutputNodes(clusterized_values);
            coordClusters.push(output_nodes)

            clustersColors = calculateClustersColors(coordClusters)

            AFFICHAGE_COURANT(rect_arcs_neurones, coordClusters, clustersColors, all_clusters)
            //windows_width - 
            //onMouseOverFunction();
        });

        MIN_NEURONE_SIZE = 5
        MAX_NEURONE_SIZE = 50   
        ESPACE_MIN_ENTRE_NEURONE = 2
        MAX_NODES_PER_COLONNE = VIS_HEIGHT / (MIN_NEURONE_SIZE * 2 + ESPACE_MIN_ENTRE_NEURONE)
        X_POS_NEURAL_NETWORK = 180

        function getSizeNeurones(nodes_number){
            var t = (VIS_HEIGHT - (ESPACE_MIN_ENTRE_NEURONE * (nodes_number + 1))) / nodes_number
            if(t/2 < MIN_NEURONE_SIZE){
                return MIN_NEURONE_SIZE
            }
            if(t/2 > MAX_NEURONE_SIZE){
                return MAX_NEURONE_SIZE
            }
            return t/2
        }

        function drawNeuronesV2(){
            var rect_layers = new Array(nb_layers)
            var texts_layers = new Array(nb_layers)

            var x_pos_layer = 60 + X_POS_NEURAL_NETWORK
            var x_pos_text_layer = 80 + X_POS_NEURAL_NETWORK

            context.fillStyle = 'black'
            context.font = "20px Arial"

            var sizes_neurones_per_layer = new Array(nb_layers + 1)
            var number_of_nodes_in_layer = new Array(nb_layers + 1)
            var nb_colonnes_in_layer = new Array(nb_layers + 1)
            var nb_lignes_in_layer = new Array(nb_layers + 1)
            var reste_in_layer = new Array(nb_layers + 1)

            // var input_class_circle = arc(80, INTERFACE_HEIGHT/2, 50, 0, 2 * Math.PI, 'green', true)
            // input_class_circle.draw()

            for(var i = 0;i < nb_layers + 1;i++){
                // if(i == 0){
                //     number_of_nodes_in_layer[i] = parseInt(info_network[0]['number_of_inputs'])
                //     var t = getHauteurLargeurLayer(number_of_nodes_in_layer[i])
                //     nb_lignes_in_layer[i] = t[0]
                //     nb_colonnes_in_layer[i] = t[1]
                //     reste_in_layer[i] = t[2]
                //     sizes_neurones_per_layer[i] = getSizeNeurones(nb_colonnes_in_layer[i] * nb_lignes_in_layer[i])
                //     number_of_nodes_in_layer[i] = number_of_nodes_in_layer[i] - reste_in_layer[i]

                if(i == nb_layers){ //output layer
                    number_of_nodes_in_layer[i] = info_network[info_network.length - 1].units
                    var t = getHauteurLargeurLayer(number_of_nodes_in_layer[i])
                    nb_lignes_in_layer[i] = t[0]
                    nb_colonnes_in_layer[i] = t[1]
                    reste_in_layer[i] = t[2]
                    sizes_neurones_per_layer[i] = getSizeNeurones(nb_colonnes_in_layer[i] * nb_lignes_in_layer[i])
                    number_of_nodes_in_layer[i] = number_of_nodes_in_layer[i] - reste_in_layer[i]
                }else{
                    number_of_nodes_in_layer[i] = info_network[i].units
                    var t = getHauteurLargeurLayer(number_of_nodes_in_layer[i])
                    nb_lignes_in_layer[i] = t[0]
                    nb_colonnes_in_layer[i] = t[1]
                    reste_in_layer[i] = t[2]
                    sizes_neurones_per_layer[i] = getSizeNeurones(nb_colonnes_in_layer[i] * nb_lignes_in_layer[i])
                    number_of_nodes_in_layer[i] = number_of_nodes_in_layer[i] - reste_in_layer[i]
                }
            }

            var arcs_neurones = new Array(nb_layers + 1)
            var rect_arcs_neurones = new Array(nb_layers + 1)

            var y = 50

            var x_pos_neurone = 200 + X_POS_NEURAL_NETWORK

            for(var i = 0;i < nb_layers + 1;i++){

                var max_x_rect = 0;
                var max_y_rect = 0
                var x_pos_neurone_debut = x_pos_neurone

                if(sizes_neurones_per_layer[i] > MIN_NEURONE_SIZE){
                    arcs_neurones[i] = new Array(1)
                    arcs_neurones[i][0] = new Array(nb_colonnes_in_layer[i])
                    var espace = VIS_HEIGHT - (2 * sizes_neurones_per_layer[i] *  number_of_nodes_in_layer[i])
                    var espace_entre_neurones = espace / (number_of_nodes_in_layer[i] + 1)
                    y += espace_entre_neurones
                    var y_save = y              
                    for (var j = 0; j < number_of_nodes_in_layer[i]; j++){                    
                        context.beginPath()
                        arcs_neurones[i][0][j] = arc(x_pos_neurone, y + sizes_neurones_per_layer[i], sizes_neurones_per_layer[i], 0, 2 * Math.PI, 'black', false);
                        arcs_neurones[i][0][j].draw()
                        y+= espace_entre_neurones + (sizes_neurones_per_layer[i] * 2)
                        context.stroke()
                        context.closePath() 
                    }
                    rect_arcs_neurones[i] = rectangle(x_pos_neurone_debut - sizes_neurones_per_layer[i],y_save, sizes_neurones_per_layer[i] * 2, ((sizes_neurones_per_layer[i] * 2) * number_of_nodes_in_layer[i]) + (espace_entre_neurones * (number_of_nodes_in_layer[i] - 1)), 'black', false) 
                    //rect_arcs_neurones[i].draw()
                }else{      
                    arcs_neurones[i] = new Array(nb_colonnes_in_layer[i])                           
                    var espace = VIS_HEIGHT - (nb_lignes_in_layer[i] * sizes_neurones_per_layer[i] * 2 + ((ESPACE_MIN_ENTRE_NEURONE * nb_lignes_in_layer[i]) - ESPACE_MIN_ENTRE_NEURONE))
                    for(var j = 0; j < nb_colonnes_in_layer[i]; j++){
                        y += espace/2
                        arcs_neurones[i][j] = new Array(nb_lignes_in_layer[i])
                        for(var k = 0; k < nb_lignes_in_layer[i]; k++){
                            context.beginPath() 
                            arcs_neurones[i][j][k] = arc(x_pos_neurone, y + sizes_neurones_per_layer[i], sizes_neurones_per_layer[i], 0, 2 * Math.PI, 'black', false);
                            arcs_neurones[i][j][k].draw();
                            context.closePath() 
                            y += ESPACE_MIN_ENTRE_NEURONE + (sizes_neurones_per_layer[i] * 2)
                            if(max_x_rect < x_pos_neurone + (sizes_neurones_per_layer[i] * 2)){
                                max_x_rect = x_pos_neurone + (sizes_neurones_per_layer[i] * 2)
                            }
                            if(max_y_rect < y + sizes_neurones_per_layer[i]){
                                max_y_rect = y
                            }
                        }
                        y = 50
                        x_pos_neurone += ESPACE_MIN_ENTRE_NEURONE + (sizes_neurones_per_layer[i] * 2)
                    }              
                    y = 50 + espace/2
                    rect_arcs_neurones[i] = rectangle(x_pos_neurone_debut - sizes_neurones_per_layer[i], y, max_x_rect - x_pos_neurone_debut, max_y_rect - y, 'black', false) 
                    //rect_arcs_neurones[i].draw()
                } 

                y = 50
                x_pos_neurone += 250
            }

            // for(var a in arcs_neurones[0][0]){
            //     var arc_neurone = arcs_neurones[0][0][a]
            //     context.strokeStyle = 'grey'
            //     context.beginPath()
            //     context.moveTo(input_class_circle.x + input_class_circle.rayon, input_class_circle.y)
            //     context.lineTo(arc_neurone.x - arc_neurone.rayon, arc_neurone.y)
            //     context.closePath()
            //     context.stroke()
            // }
            return [rect_arcs_neurones, arcs_neurones]
        }

        function getTextWidth(text, font) {
            // re-use canvas object for better performance
            context.font = font;
            var metrics = context.measureText(text);
            return metrics.width;
        }

        var colors = [
            "#63b598", "#ce7d78", "#ea9e70", "#a48a9e", "#c6e1e8", "#648177" ,"#0d5ac1" ,
            "#f205e6" ,"#1c0365" ,"#14a9ad" ,"#4ca2f9" ,"#a4e43f" ,"#d298e2" ,"#6119d0",
            "#d2737d" ,"#c0a43c" ,"#f2510e" ,"#651be6" ,"#79806e" ,"#61da5e" ,"#cd2f00" ,
            "#9348af" ,"#01ac53" ,"#c5a4fb" ,"#996635","#b11573" ,"#4bb473" ,"#75d89e" ,
            "#2f3f94" ,"#2f7b99" ,"#da967d" ,"#34891f" ,"#b0d87b" ,"#ca4751" ,"#7e50a8" ,
            "#c4d647" ,"#e0eeb8" ,"#11dec1" ,"#289812" ,"#566ca0" ,"#ffdbe1" ,"#2f1179" ,
            "#935b6d" ,"#916988" ,"#513d98" ,"#aead3a", "#9e6d71", "#4b5bdc", "#0cd36d",
            "#250662", "#cb5bea", "#228916", "#ac3e1b", "#df514a", "#539397", "#880977",
            "#f697c1", "#ba96ce", "#679c9d", "#c6c42c", "#5d2c52", "#48b41b", "#e1cf3b",
            "#5be4f0", "#57c4d8", "#a4d17a", "#225b8", "#be608b", "#96b00c", "#088baf",
            "#f158bf", "#e145ba", "#ee91e3", "#05d371", "#5426e0", "#4834d0", "#802234",
            "#6749e8", "#0971f0", "#8fb413", "#b2b4f0", "#c3c89d", "#c9a941", "#41d158",
            "#fb21a3", "#51aed9", "#5bb32d", "#807fb", "#21538e", "#89d534", "#d36647",
            "#7fb411", "#0023b8", "#3b8c2a", "#986b53", "#f50422", "#983f7a", "#ea24a3",
            "#79352c", "#521250", "#c79ed2", "#d6dd92", "#e33e52", "#b2be57", "#fa06ec",
            "#1bb699", "#6b2e5f", "#64820f", "#1c271", "#21538e", "#89d534", "#d36647",
            "#7fb411", "#0023b8", "#3b8c2a", "#986b53", "#f50422", "#983f7a", "#ea24a3",
            "#79352c", "#521250", "#c79ed2", "#d6dd92", "#e33e52", "#b2be57", "#fa06ec",
            "#1bb699", "#6b2e5f", "#64820f", "#1c271", "#9cb64a", "#996c48", "#9ab9b7",
            "#06e052", "#e3a481", "#0eb621", "#fc458e", "#b2db15", "#aa226d", "#792ed8",
            "#73872a", "#520d3a", "#cefcb8", "#a5b3d9", "#7d1d85", "#c4fd57", "#f1ae16",
            "#8fe22a", "#ef6e3c", "#243eeb", "#1dc18", "#dd93fd", "#3f8473", "#e7dbce",
            "#421f79", "#7a3d93", "#635f6d", "#93f2d7", "#9b5c2a", "#15b9ee", "#0f5997",
            "#409188", "#911e20", "#1350ce", "#10e5b1", "#fff4d7", "#cb2582", "#ce00be",
            "#32d5d6", "#17232", "#608572", "#c79bc2", "#00f87c", "#77772a", "#6995ba",
            "#fc6b57", "#f07815", "#8fd883", "#060e27", "#96e591", "#21d52e", "#d00043",
            "#b47162", "#1ec227", "#4f0f6f", "#1d1d58", "#947002", "#bde052", "#e08c56",
            "#28fcfd", "#bb09b", "#36486a", "#d02e29", "#1ae6db", "#3e464c", "#a84a8f",
            "#911e7e", "#3f16d9", "#0f525f", "#ac7c0a", "#b4c086", "#c9d730", "#30cc49",
            "#3d6751", "#fb4c03", "#640fc1", "#62c03e", "#d3493a", "#88aa0b", "#406df9",
            "#615af0", "#4be47", "#2a3434", "#4a543f", "#79bca0", "#a8b8d4", "#00efd4",
            "#7ad236", "#7260d8", "#1deaa7", "#06f43a", "#823c59", "#e3d94c", "#dc1c06",
            "#f53b2a", "#b46238", "#2dfff6", "#a82b89", "#1a8011", "#436a9f", "#1a806a",
            "#4cf09d", "#c188a2", "#67eb4b", "#b308d3", "#fc7e41", "#af3101", "#ff065",
            "#71b1f4", "#a2f8a5", "#e23dd0", "#d3486d", "#00f7f9", "#474893", "#3cec35",
            "#1c65cb", "#5d1d0c", "#2d7d2a", "#ff3420", "#5cdd87", "#a259a4", "#e4ac44",
            "#1bede6", "#8798a4", "#d7790f", "#b2c24f", "#de73c2", "#d70a9c", "#25b67",
            "#88e9b8", "#c2b0e2", "#86e98f", "#ae90e2", "#1a806b", "#436a9e", "#0ec0ff",
            "#f812b3", "#b17fc9", "#8d6c2f", "#d3277a", "#2ca1ae", "#9685eb", "#8a96c6",
            "#dba2e6", "#76fc1b", "#608fa4", "#20f6ba", "#07d7f6", "#dce77a", "#77ecca"]


        function getClustColor(clustersColors, clustClass){
            for(var cc of clustersColors){
                if(cc['clusterClass'] == clustClass){
                    return cc['color']
                }
            }
        }

        function calculateClustersColors(coordClusters){
            var clustersColors = new Array()
            var clusterClasses = new Array()
            console.log(coordClusters)
            for(var i = 0; i < coordClusters.length; i++){
                for(var j = 0; j < coordClusters[i].length; j++){
                    var clusterClass;
                    if(i == 0 || i == coordClusters.length - 1){
                        clusterClass = coordClusters[i][j]['clust_index'] + ' '
                    }else{
                        clusterClass = ''
                        for(var class_ of coordClusters[i][j]['main_classes']){
                            clusterClass += class_['class'] + ' '
                        }
                    }
                    if(!clusterClasses.includes(clusterClass)){
                        clusterClasses.push(clusterClass)
                    }
                } 
            }
            var color_index = 0
            for(var class_ of clusterClasses){
                clustersColors.push(new Object({'clusterClass': class_, 'color': colors[color_index]}))
                color_index++
            }

            return clustersColors
        }



        var TAILLE_MIN_SIGNATURE = 10

        function initSankey(){

            var margin = {top: 0, right: 0, bottom: 0, left: 0},
            width = canvas.width - margin.left - margin.right,
            height = canvas.height - margin.top - margin.bottom;

            var svg = d3.select("#my_dataviz").html('')

            // append the svg object to the body of the page
            svg = d3.select("#my_dataviz").append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // Color scale used
            var color = d3.scaleOrdinal(d3.schemeCategory20);

            // Set the sankey diagram properties
            var sankey = d3.sankey()
                .nodeWidth(36)
                .nodePadding(290)
                .size([width, height]);

            graph = new Object({
                    "nodes": new Array(),
                    "links": new Array()
                })

                var node_index = 0

                for(var l = 0; l < coordClusters.length; l++){
                    for(var c = 0; c < coordClusters[l].length; c++){
                        var node = new Object()
                        node.node = coordClusters[l][c]['clust_index']
                        var layer_number = l
                        node.name = 'l' + layer_number + 'c' + coordClusters[l][c]['clust_index']
                        if(l == 0 || l == coordClusters.length - 1){
                            node.color = getClustColor(clustersColors, coordClusters[l][c]['clust_index'] + ' ')
                        }else{
                            var clusterClass = '' 
                            for(var _class of coordClusters[l][c]['main_classes']){
                                clusterClass += _class['class'] + ' '
                            }
                            node.color = getClustColor(clustersColors, clusterClass)
                        }
                        graph.nodes.push(node)
                    }
                }

            return [graph, sankey, svg]
        }

        function loadSankeyVueDensemble(rect_arcs_neurones, coordClusters, clustersColors){

                var res= initSankey()
                var graph = res[0]
                var sankey = res[1]
                var svg = res[2]

                var nb_links = coordClusters.length - 1

                for(var v of clusterized_values){
                    for(var i = 0; i < nb_links; i++){
                        var link = new Object()
                        if(i == 0){
                            for(var n = 0;n < graph.nodes.length; n++){
                                if(graph.nodes[n].name == 'l0c' + parseInt(v['input_class'])){
                                    link.source = n
                                }
                                if(graph.nodes[n].name == 'l1c' + parseInt(v['cluster_in_layer1'])){
                                    link.target = n
                                }
                            }
                        }else if(i == nb_links - 1){
                            for(var n = 0;n < graph.nodes.length; n++){
                                if(graph.nodes[n].name == 'l' + i + 'c' + parseInt(v['cluster_in_layer'+i])){
                                    link.source = n
                                }
                                if(graph.nodes[n].name == 'l' + (i+1) + 'c' + parseInt(v['output_class'])){
                                    link.target = n
                                }
                            }
                        }else{
                            for(var n = 0;n < graph.nodes.length; n++){
                                if(graph.nodes[n].name == 'l' + i + 'c' + parseInt(v['cluster_in_layer'+i])){
                                    link.source = n
                                }
                                if(graph.nodes[n].name == 'l' + (i+1) + 'c' + parseInt(v['cluster_in_layer'+(i+1)])){
                                    link.target = n
                                }
                            }
                        }
                        link.value = v['instances']
                        link.color = getClustColor(clustersColors, v['input_class'] + ' ')
                        var b = 1
                        for(l of graph.links){
                            if(l.source == link.source && l.target == link.target && l.color === link.color){
                                l.value += link.value
                                b = -1
                                continue
                            }
                        }
                        if(b == 1){
                            graph.links.push(link)
                        }
                    }                   
                }

                sankey
                .nodes(graph.nodes)
                .links(graph.links)
                .layout(1);

                var totValue = 0
                for(var n = 0; n < coordClusters[0].length; n++){
                    totValue += graph.nodes[n].value
                }        

                var y_save;
                var svgLayerTexts = []
                var x_save;
                for(var l = 0; l < coordClusters.length; l++){
                    if(l == 0){
                        y_save = 50
                        for(var c = 0; c < coordClusters[0].length; c++){
                            graph.nodes[c].x = 50
                            graph.nodes[c].y = y_save
                            graph.nodes[c].dy = VIS_HEIGHT * coordClusters[l][c]['proportion']
                            y_save += graph.nodes[c].dy
                        }
                        var svgInputText = svg.append("text").attr("x", 25).attr("y", y_save + 25)
                        svgInputText.text("Input layer")
                    }else if(l == coordClusters.length - 1 ){
                        y_save = 50                      
                        for(var c = 0; c < coordClusters[l].length; c++){
                            var node_index = coordClusters[0].length + (l-1) * coordClusters[l-1].length + c
                            graph.nodes[node_index].y = y_save
                            graph.nodes[node_index].dy = VIS_HEIGHT * coordClusters[l][c]['proportion']
                            graph.nodes[node_index].x = rect_arcs_neurones[l-1].x + (rect_arcs_neurones[l-1].w)
                            x_save = rect_arcs_neurones[l-1].x + (rect_arcs_neurones[l-1].w)
                            y_save += graph.nodes[node_index].dy
                        }
                        var svgOutputText = svg.append("text").attr("x", x_save - 40).attr("y", y_save + 25)
                        svgOutputText.text("Output layer")
                    }else{
                            y_save = 50
                            for(var c = 0; c < coordClusters[l].length; c++){
                                var node_index = coordClusters[0].length + (l-1) * coordClusters[l].length + c
                                graph.nodes[node_index].x = rect_arcs_neurones[l-1].x + rect_arcs_neurones[l-1].w
                                x_save = graph.nodes[node_index].x
                                graph.nodes[node_index].y = y_save
                                graph.nodes[node_index].dy = VIS_HEIGHT * (graph.nodes[node_index].value / totValue)
                                graph.nodes[node_index].main_classes = coordClusters[l][c].main_classes
                                graph.nodes[node_index].minor_classes = coordClusters[l][c].minor_classes
                                y_save += VIS_HEIGHT * (graph.nodes[node_index].value / totValue)
                            }
                            svgLayerTexts.push(svg.append("text").attr("x", x_save - 30).attr("y", y_save + 25).text("Hidden Layer " + l))
                    }
                }

                var totDy = 0
                for(var n = 0; n < coordClusters[0].length; n++){
                    totDy += graph.nodes[n].dy
                }

                 for(var link of graph.links){
                     link.dy = totDy * link.value / totValue
                 }

                 for(node of graph.nodes){
                     var sy = 0
                     var ty = 0

                     node.targetLinks.sort(function (a, b){
                         return b.value - a.value
                     })
                     for(link of node.targetLinks){
                        link.ty = ty
                        ty += link.dy
                     }

                    var colors = []
                    
                    if(node.targetLinks.length == 0 && node.sourceLinks.length > 0){
                        colors.push(node.sourceLinks[0].color)
                    }else{
                        for(link of node.targetLinks){
                            if(!colors.includes(link.color)){
                                colors.push(link.color)
                            }
                        }
                    }                

                    for(color of colors){
                        var links = []
                        for(var i = 0; i < node.sourceLinks.length; i++){
                            if(node.sourceLinks[i].color === color){
                                links.push(new Object({'index': i, 'value': node.sourceLinks[i].value}))
                            }
                        }
                        links.sort(function(a, b){
                            return b.value - a.value
                        })
                        for(l of links){
                            node.sourceLinks[l['index']].sy = sy
                            sy += node.sourceLinks[l['index']].dy
                        }
                    }

                 }

                 for(node of graph.nodes){
                    var ty = 0

                    var colors_in_order = []

                    var temp_sy

                    if(node.sourceLinks.length > 0){
                        temp_sy = node.sourceLinks[0].sy
                    }

                    var end = false

                    while(!end){
                        end = true
                        var l_color = ''
                        var min_sy = Infinity;
                        for(var i = 0; i < node.sourceLinks.length; i++){
                            if(node.sourceLinks[i].sy < min_sy && !colors_in_order.includes(node.sourceLinks[i].color)){
                                min_sy = node.sourceLinks[i].sy
                                l_color = node.sourceLinks[i].color
                                end = false
                            }
                        }
                        if(l_color.length > 0){
                            colors_in_order.push(l_color)
                        }          
                    }                
                    for(color of colors_in_order){
                        var links = []
                        for(var i = 0; i < node.targetLinks.length; i++){
                            if(node.targetLinks[i].color === color){
                                links.push(new Object({'index': i, 'value': node.targetLinks[i].value}))
                            }
                        }
                        links.sort(function(a, b){
                            return b.value - a.value
                        })
                        for(l of links){
                            node.targetLinks[l['index']].ty = ty
                            ty += node.targetLinks[l['index']].dy
                        }
                    }

                 }
                 

                    // add in the links
                var link = svg.append("g")
                    .selectAll(".link")
                    .data(graph.links)
                    .enter()
                    .append("path")
                    .attr("class", "link")
                    .attr("color", function(d){return d.color;})
                    .attr("d", sankey.link() )
                    .style("stroke-width", function(d) { return Math.max(1, d.dy); })
                    .style('stroke', function(d){return d.color;})
                    .on("mouseover", function(d) {
                        var link_color = d.color
                        $('.link').css("stroke-opacity",  "0.2")
                        $('.link[color="'+link_color+'"').css("stroke-opacity",  "0.8")
                    }) 
                    .on("mouseout", function(d) {
                        $('.link').css("stroke-opacity",  "0.2")
                    }) 

                // add in the nodes
                var node = svg.append("g")
                    .selectAll(".node")
                    .data(graph.nodes)
                    .enter().append("g")
                    .attr("class", "node")
                    .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; })

                // add the rectangles for the nodes
                node
                    .append("rect")
                    .attr("height", function(d) { return d.dy; })
                    .attr("width", sankey.nodeWidth())
                    .style("fill", function(d) { return d.color;}) 
                    .style("stroke", function(d) { return d3.rgb(d.color).darker(2); })
                    // Add hover text
                    .append("title")
                    .text(function(d) { return d.name + "\n" + d.value + "\n main: " + JSON.stringify(d.main_classes) + "\n minor: " + JSON.stringify(d.minor_classes)});
                
                
        }

        function loadSankey(rect_arcs_neurones, coordClusters, clustersColors){

            
            var res= initSankey()
            var graph = res[0]
            var sankey = res[1]
            var svg = res[2]

            var node_index = 0

            var l_color;
            for(var c_color of clustersColors){
                if(c_color['clusterClass'] === input_signature['input_class'] + ' '){
                    l_color = c_color['color']
                    break
                }
            }

            for(var l = 0; l < coordClusters.length; l++){
                var layer_number = l
                for(var c = 0; c < coordClusters[l].length; c++){                   
                    if(l == 0){
                        if(input_signature['input_class'] == coordClusters[l][c]['clust_index']){
                            var link = new Object()
                            for(var n = 0;n < graph.nodes.length; n++){
                                if(graph.nodes[n].name == 'l'+layer_number+'c' + parseInt(input_signature['input_class'])){
                                    link.source = n
                                }
                                if(graph.nodes[n].name == 'l'+(layer_number+1)+'c' + parseInt(input_signature['cluster_in_layer'+(layer_number+1)])){
                                    link.target = n
                                }
                            }
                            link.value = input_signature["instances"]
                            link.color = l_color
                            graph.links.push(link)
                        }
                    }else if(l == coordClusters.length - 2){
                        if(input_signature['cluster_in_layer'+layer_number] == c){
                            var link = new Object()
                            for(var n = 0;n < graph.nodes.length; n++){
                                if(graph.nodes[n].name == 'l'+layer_number+'c' + parseInt(input_signature['cluster_in_layer'+(layer_number)])){
                                    link.source = n
                                }
                                if(graph.nodes[n].name == 'l'+(layer_number+1)+'c' + parseInt(input_signature['output_class'])){
                                    link.target = n
                                }
                            }
                            link.value = input_signature["instances"]
                            link.color = l_color
                            graph.links.push(link)
                        }
                    }else if(l < coordClusters.length - 2){
                        if(input_signature['cluster_in_layer'+layer_number] == c){
                            var link = new Object()
                            for(var n = 0;n < graph.nodes.length; n++){
                                if(graph.nodes[n].name == 'l'+layer_number+'c' + parseInt(input_signature['cluster_in_layer'+(layer_number)])){
                                    link.source = n
                                }
                                if(graph.nodes[n].name == 'l'+(layer_number+1)+'c' + parseInt(input_signature['cluster_in_layer'+(layer_number+1)])){
                                    link.target = n
                                }
                            }
                            link.value = input_signature["instances"]
                            link.color = l_color
                            graph.links.push(link)
                        }
                    }              
                }
            }

            sankey
                .nodes(graph.nodes)
                .links(graph.links)
                .layout(1);

            var totValue = 0
            for(c of coordClusters[1]){
                 totValue += c['signatures_count']
            }

            var y_save;
            var x_save;
            var svgLayerTexts = []
            for(var l = 0; l < coordClusters.length; l++){

                    if(l == 0){
                        y_save = 50
                        for(var c = 0; c < coordClusters[0].length; c++){
                            graph.nodes[c].x = 50
                            graph.nodes[c].y = y_save
                            graph.nodes[c].dy = VIS_HEIGHT * coordClusters[l][c]['proportion']
                            y_save += graph.nodes[c].dy
                        }
                        var svgInputText = svg.append("text").attr("x", 25).attr("y", y_save + 25)
                        svgInputText.text("Input layer")
                    }else if(l == coordClusters.length - 1 ){
                        y_save = 50
                        for(var c = 0; c < coordClusters[l].length; c++){
                            var node_index = coordClusters[0].length + (l-1) * coordClusters[l-1].length + c
                            graph.nodes[node_index].y = y_save
                            graph.nodes[node_index].dy = VIS_HEIGHT * coordClusters[l][c]['proportion']
                            graph.nodes[node_index].x = rect_arcs_neurones[l-1].x + (rect_arcs_neurones[l-1].w)
                            x_save = graph.nodes[node_index].x
                            y_save += graph.nodes[node_index].dy
                        }
                        var svgOutputText = svg.append("text").attr("x", x_save - 40).attr("y", y_save + 25)
                        svgOutputText.text("Output layer")
                    }else{
                            y_save = 50
                            for(var c = 0; c < coordClusters[l].length; c++){
                                var node_index = coordClusters[0].length + (l-1) * coordClusters[l].length + c
                                graph.nodes[node_index].x = rect_arcs_neurones[l-1].x + rect_arcs_neurones[l-1].w
                                x_save = graph.nodes[node_index].x
                                graph.nodes[node_index].y = y_save
                                graph.nodes[node_index].dy = VIS_HEIGHT * (coordClusters[l][c]['signatures_count'] / totValue)
                                graph.nodes[node_index].main_classes = coordClusters[l][c].main_classes
                                y_save += graph.nodes[node_index].dy 
                            }
                            svgLayerTexts.push(svg.append("text").attr("x", x_save - 30).attr("y", y_save + 25).text("Hidden Layer " + l))
                    }
                }

                for(var link of graph.links){
                    var dy = VIS_HEIGHT * (link.value / totValue)
                    if(dy < 10){
                        link.dy = 10
                    }else{
                        link.dy = dy
                    }
                    
                }

                    // add in the links
                var link = svg.append("g")
                    .selectAll(".link")
                    .data(graph.links)
                    .enter()
                    .append("path")
                    .attr("class", "link")
                    .attr("color", function(d){return d.color;})
                    .attr("d", sankey.link() )
                    .style("stroke-width", function(d) { return Math.max(1, d.dy); })
                    .style('stroke', function(d){return d.color;})
                    .on("mouseover", function(d) {
                        var link_color = d.color
                        $('.link').css("stroke-opacity",  "0.2")
                        $('.link[color="'+link_color+'"').css("stroke-opacity",  "0.8")
                    }) 
                    .on("mouseout", function(d) {
                        $('.link').css("stroke-opacity",  "0.2")
                    })

                // add in the nodes
                var node = svg.append("g")
                    .selectAll(".node")
                    .data(graph.nodes)
                    .enter().append("g")
                    .attr("class", "node")
                    .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; })

                // add the rectangles for the nodes
                node
                    .append("rect")
                    .attr("height", function(d) { return d.dy; })
                    .attr("width", sankey.nodeWidth())
                    .style("fill", function(d) { return d.color;}) 
                    .style("stroke", function(d) { return d3.rgb(d.color).darker(2); })
                    // Add hover text
                    .append("title")
                    .text(function(d) { return d.name + "\n" + d.value + "\n main: " + JSON.stringify(d.main_classes) + "\n minor: " + JSON.stringify(d.minor_classes)});
             
        }

        function drawLignesNeurones(arcs_neurones){
            for(var i = 0;i < arcs_neurones.length - 1; i++){
                for(var a1 in arcs_neurones[i][arcs_neurones[i].length - 1]){
                    var arc1 = arcs_neurones[i][arcs_neurones[i].length - 1][a1]
                    for(var a2 in arcs_neurones[i+1][0]){
                        var arc2 = arcs_neurones[i+1][0][a2]
                        context.beginPath();
                        // if(i == 0){
                        //     context.strokeStyle = "grey"; 
                        // }else{
                            context.strokeStyle = "#808080";
                        // }
                        context.moveTo(arc1.x + arc1.rayon, arc1.y);
                        context.lineTo(arc2.x - arc2.rayon, arc2.y);
                        context.stroke();
                        context.closePath()
                    }
                }
            }
        }

        ESPACE_ENTRE_CLUSTERS = 5

        function moy_class(classes){
            var tot = 0
            for(var c of classes){
                tot += c['class']
            }
            return tot/classes.length
        }

        function compare(a, b) {

            if(moy_class(a.main_classes) == moy_class(b.main_classes)){
                return b.signatures_count - a.signatures_count
            }

            return moy_class(a.main_classes) - moy_class(b.main_classes)

        }


        function calculClusters(clusters, nb_clusters, clusterized_values, nb_layer){
            var clust_infos = new Array()
            for(var i = 0; i < nb_clusters; i++){
                clust_infos.push(new Object({'clust_index': i, 'main_classes' : new Array(), 'minor_classes': new Array(), 'instances_count': 0, 'signatures_count': 0, 'proportion': 0}))
            }

            for(var i = 0; i < clusterized_values.length; i++){
                clust_infos[parseInt(clusterized_values[i]['cluster_in_layer'+nb_layer])]['signatures_count'] += parseInt(clusterized_values[i]['instances'])
            }

            var total = 0

            for(c of clusters){
                var clust_index = c["cluster_index"]
                clust_infos[clust_index].instances_count += c["instances_count"]
                total += c["instances_count"]
            }

            for(c of clust_infos){
                c.proportion = c.instances_count / total
            }

            for(c of clusters){
                var clust_index = c["cluster_index"]
                if(c["instances_count"] < (0.1 * clust_infos[clust_index].instances_count)){
                    clust_infos[clust_index].minor_classes.push(new Object({'class': c["class"], 'count': c["instances_count"]}))
                }else{
                    clust_infos[clust_index].main_classes.push(new Object({'class': c["class"], 'count': c["instances_count"]}))
                }
            }

            clust_infos.sort(compare);

            console.log(clust_infos)

            return clust_infos
        }

        function getOutputNodes(clusterized_values){
            var output_nodes = new Array()
            var total = 0
            for(c of clusterized_values){
                var found = false
                for(o of output_nodes){
                    if(o['clust_index'] == parseInt(c['output_class'])){
                        o['instances'] += c['instances']
                        total += c['instances']
                        found = true
                    }
                }
                if(!found){
                    output_nodes.push(new Object({'clust_index': parseInt(c['output_class']), 'instances': c['instances']}))
                    total += c['instances']
                }
            }
            for(var obj of output_nodes){
                obj['proportion'] = obj['instances'] / total
            }

            output_nodes.sort(function(a, b){
                return a.clust_index - b.clust_index
            })

            return output_nodes
        }

        function arc(x, y, rayon, angleDepart, angleFin, color, fill) {
            var arc = {
                x: x,
                y: y,
                rayon: rayon,
                angleDepart: angleDepart,
                angleFin: angleFin,
                color : color,
                f: fill,

                draw: function () {
                    context.beginPath();
                    context.arc(this.x, this.y, this.rayon, this.angleDepart, this.angleFin);
                    context.strokeStyle = this.color;
                    // context.lineWidth = "2";
                    if(this.f){
                        context.fillStyle = color;
                        context.fill()
                    }
                    context.stroke();
                    context.closePath();
                }
            };
            return arc;
        }

        

        function rectangle(rx, ry, w, h, color, fill) {
            var rec = {
                x: rx,
                y: ry,
                w: w,
                h: h,
                f: fill,

                draw: function () {
                    context.beginPath();
                    context.strokeStyle = color;
                    context.lineWidth = "2";
                    context.rect(this.x, this.y, this.w, this.h);
                    if(this.f){
                        context.fillStyle = color;
                        context.fillRect(this.x, this.y, this.w, this.h);
                    }
                    context.stroke();
                    context.closePath();

                }
            };
            return rec;
        }

        var input_text, output_text;

        var signature_index = 0;
        input_signature = new Object();
        input_signature.input_class = parseInt(clusterized_values[signature_index]['input_class'])
        for(var i = 1;i <= nb_layers;i++){
            input_signature['cluster_in_layer'+i] = parseInt(clusterized_values[signature_index]['cluster_in_layer'+i])
        }
        input_signature.output_class = parseInt(clusterized_values[signature_index]['output_class'])
        input_signature.instances = clusterized_values[signature_index]['instances']
        //document.getElementById("index").innerText = signature_index


        var polygons_paths, example_path

        function draw() {

            //layers
            var rect_layers = new Array(nb_layers)
            var texts_layers = new Array(nb_layers)

            var x_pos_layer = 60
            var x_pos_text_layer = 80

            context.fillStyle = 'black'
            context.strokeStyle = 'black'
            context.font = "20px Arial"
            
            context.clearRect(0, 0, canvas.width, canvas.height);

            var t = drawNeuronesV2()
            var rect_arcs_neurones = t[0]
            var arcs_neurones = t[1]

            //drawLignesNeurones(arcs_neurones)

            var coordClusters = new Array(nb_layers)

            context.stroke()

            return rect_arcs_neurones
        }

        function drawSignature(signature_index){
            input_signature = new Object();
            input_signature.input_class = parseInt(clusterized_values[signature_index]['input_class'])
            for(var i = 1;i <= nb_layers;i++){
                input_signature['cluster_in_layer'+i] = parseInt(clusterized_values[signature_index]['cluster_in_layer'+i])
            }
            input_signature.output_class = parseInt(clusterized_values[signature_index]['output_class'])
            input_signature.instances = clusterized_values[signature_index]['instances']
            //document.getElementById("index").innerText = signature_index
            //drawClusters(rect_arcs_neurones, coordClusters)
            AFFICHAGE_COURANT(rect_arcs_neurones, coordClusters, clustersColors)
        }

  </script>
  <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>
</body>
</html>